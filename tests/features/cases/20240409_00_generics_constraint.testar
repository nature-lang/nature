=== test_param_mismatch
--- main.n
import 'mod.n'

fn main() {
    var f2 = mod.foo_t<f32, bool>{
        a: 233.333,
        b: true,
    }
    var a2 = @ula(f2).dump()

}

--- mod.n
// 类型约束一致性检查
type foo_t<T:f32|bool|int, U:bool|string|f32|[i32]> = struct{
    T a
    U b
    float c
}

fn foo_t<T, U>.dump(&self):T {
   println('bar_t any dump', self.a)
   return self.a
}

fn foo_t<T:f32, U:bool>.dump(&self):T {
    println('f32+bool dump', self.a, self.b)
    return self.a
}

fn foo_t<T:f32|bool, U:string>.dump(&self, U c) {
    println('void return, f32|bool+int|string dump', self.a, self.b, c)
}

--- output.txt
nature-test/mod.n:8:2: type 'nature-test.mod.foo_t' param constraint mismatch


=== test_failed2
--- main.n
import 'mod.n'

fn main() {
    var f2 = mod.foo_t<f32, int>{
        a: 233.333,
        b: 1.1,
    }
    var a2 = f2.dump()
}

--- mod.n
type foo_t<T:f32|bool|int, U:bool|string|f32|[i32]> = struct{
    T a
    U b
    float c
}

fn foo_t<T:f32, U:bool>.dump(self):T {
    println('f32+bool dump', self.a, self.b)
    return self.a
}

fn foo_t<T:f32|bool, U:string>.dump(self, U c) {
    println('void return, f32|bool+int|string dump', self.a, self.b, c)
}

--- output.txt
nature-test/main.n:4:33: type 'int(i64)' does not match any of the constraints


=== test_failed3
--- main.n
import 'mod.n'

fn main() {
    var f2 = mod.foo_t<f32, f32>{
        a: 233.333,
        b: 1.1,
    }
    var a2 = f2.dump()
}

--- mod.n
type foo_t<T:f32|bool|int, U:bool|string|f32|[i32]> = struct{
    T a
    U b
    float c
}

fn foo_t<T:f32, U:bool>.dump(self):T {
    println('f32+bool dump', self.a, self.b)
    return self.a
}

fn foo_t<T:f32|bool, U:string>.dump(self, U c) {
    println('void return, f32|bool+int|string dump', self.a, self.b, c)
}

--- output.txt
nature-test/main.n:8:15: type 'nature-test.mod.foo_t<f32,f32>(struct)' not impl 'dump' fn


=== test_gen_constraint
--- main.n
import 'mod.n'

fn main() {
    var f = mod.bar_t<int, f32>{
        a: 233,
        b: 333.444,
    }
    int a = f.dump()

    var f2 = mod.foo_t<f32, bool>{
        a: 233.333,
        b: true,
    }
    var a2 = f2.dump()


    var f3 = mod.foo_t<bool, string>{
        a: true,
        b: 'hello',
    }
    f3.dump('world')

    var f4 = mod.bar_t<f32, [i32]>{
        a: 233.333,
        b: [1, 2, 3],
    }
    f4.dump()
}

--- mod.n
type foo_t<T:f32|bool|int, U:bool|string|f32|[i32]> = struct{
    T a
    U b
    float c
}

type bar_t<T,U> = struct{
    T a
    U b
}

fn bar_t<T, U>.dump(self):T {
   println('bar_t any dump', self.a)
   return self.a
}

fn foo_t<T:f32, U:bool>.dump(self):T {
    println('f32+bool dump', self.a, self.b)
    return self.a
}

fn foo_t<T:f32|bool, U:string>.dump(self, U c) {
    println('void return, f32|bool+int|string dump', self.a, self.b, c)
}

--- output.txt
bar_t any dump 233
f32+bool dump 233.332993 true
void return, f32|bool+int|string dump true hello world
bar_t any dump 233.332993

=== test_gen_impl_call_failed
--- main.n
fn main() {
    var ips = vec.new("", 0)
}

--- output.txt
nature-test/main.n:2:22: type 'vec' expects 1 type argument(s), but got 0

