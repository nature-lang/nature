=== test_basic
--- main.n
import net.tcp
import co

fn server():void! {
    var listener = tcp.listen('127.0.0.1:8080')

    for true {
        var conn = listener.accept()
        go fn():void! {
            var buf = vec_new<u8>(0, 1024)
            for true {
                var len = conn.read(buf) catch e {
                    if e.msg() != 'end of file' {
                        println('conn read err:', e.msg())
                    }
                    -1
                }
                if len == -1 {
                    break
                }
                conn.write(buf.slice(0, len))
            }

            conn.close()
        }()
    }

    listener.close()
}

fn main() {
    // start server
    go server()

    co.sleep(1000)

    var conn = tcp.connect('127.0.0.1:8080')
    var buf = vec_new<u8>(0, 1024)
    // write
    conn.write('hello world' as [u8])
    // read
    var len = conn.read(buf)
    println('read buf 1:', buf.slice(0, len) as string)

    conn.write('hello nature' as [u8])
    len =  conn.read(buf)
    println('read buf 2:', buf.slice(0, len) as string)

    conn.close()
}

--- output.txt
read buf 1: hello world
read buf 2: hello nature

=== test_connect_timeout
--- main.n
import net.tcp
import co

fn main() {
    var conn = tcp.connect_timeout('10.255.255.1:8080', 1000) catch e {
        throw errorf(e.msg())
    }
    conn.close()
}

--- output.txt
coroutine 'main' uncaught error: 'connection timeout' at nature-test/main.n:6:22


=== test_cross_goroutine
--- main.n
import net.tcp
import co
import runtime
import time

fn server():void! {
    var listener = tcp.listen('0.0.0.0:8080')
    var buf = vec_new<u8>(0, 1024)
    println('server is start')
    var response = 'HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\nContent-Length: 11\r\nConnection: close\r\n\r\nhello world'

    for true {
        var c = listener.accept()
        go fn(ptr<tcp.conn_t> conn):void! {
            conn.read(buf) catch e {
                conn.close()
                return
            }

            conn.write(response as [u8])
            conn.close()
        }(c)
    }

    listener.close()
}

fn main() {
    // start server
    go server()

    // 等待 server 启动成功
    co.sleep(500)

   var resp_buf = vec_new<u8>(0, 1024)

    // client
    int start = time.now().ms_timestamp()
    int count = 1000
    int every = 10
    var done = chan_new<bool>()
    for int i = 0; i < count; i += 1 {
        go fn(int i):void! {
             for int j = 0; j < every; j += 1 {
                 var conn = tcp.connect('127.0.0.1:8080')

                  // 构造HTTP GET请求
                  var http_request = 'GET / HTTP/1.1\r\n' +
                                     'Host: 127.0.0.1:8080\r\n' +
                                     'Connection: close\r\n' +
                                     '\r\n'

                  conn.write(http_request as [u8])
                  int len = conn.read(resp_buf) catch e {}
                  conn.close()
                  // println(resp_buf[0..len] as string)
             }

            done.send(true)
        }(i)
    }
    for int i = 0; i < count; i += 1 {
        done.recv()
    }

    var end = time.now().ms_timestamp()
    println('done, use time(ms): ', end - start)
}


=== test_close
--- main.n
import net.tcp
import co
import runtime
import time

fn server():void! {
    var listener = tcp.listen('0.0.0.0:8080')
    var buf = vec_new<u8>(0, 1024)
    println('server is start')
    var response = 'HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\nContent-Length: 11\r\nConnection: close\r\n\r\nhello world'

    var conn = listener.accept()

    conn.close()

    conn.read(buf) catch e {
        panic(e.msg())
        return
    }

    conn.write(response as [u8])

    listener.close()
}

fn main() {
    // start server
    go server()

    // 等待 server 启动成功
    co.sleep(500)

    var conn = tcp.connect('127.0.0.1:8080')
    conn.close()

    co.sleep(500) // wait exception
}

--- output.txt
server is start
coroutine '1' panic: 'conn closed' at nature-test/main.n:17:15

=== test_url_parser
--- main.n
import net.url

fn main() {
    println("Testing URL parser...")

    // Test 1: Basic HTTP URL
    test_basic_http()

    // Test 2: HTTPS URL with port
    test_https_with_port()

    // Test 3: URL with path
    test_url_with_path()

    // Test 4: URL with query parameters
    test_url_with_query()

    // Test 5: URL with fragment
    test_url_with_fragment()

    // Test 6: Complete URL with all components
    test_complete_url()

    // Test 7: URL with encoded characters
    test_url_with_encoding()

    // Test 8: URL with multiple query parameters
    test_multiple_query_params()

    // Test 9: Edge cases
    test_edge_cases()

    // Test 10: Error cases
    test_error_cases()

    println("All tests completed!")
}

fn test_basic_http():void! {
    println("Test 1: Basic HTTP URL")
    var result = url.parse("http://example.com")
    assert(result.scheme == "http")
    assert(result.hostname == "example.com")
    assert(result.authority == "example.com")
    assert(result.port == 0)
    assert(result.path == "/")
    assert(result.raw_query == "")
    assert(result.fragment == "")
    println("✓ Basic HTTP URL test passed")
}

fn test_https_with_port():void! {
    println("Test 2: HTTPS URL with port")
    var result = url.parse("https://example.com:8080")
    assert(result.scheme == "https")
    assert(result.hostname == "example.com")
    assert(result.authority == "example.com:8080")
    assert(result.port == 8080)
    assert(result.path == "/")
    assert(result.raw_query == "")
    assert(result.fragment == "")
    println("✓ HTTPS with port test passed")
}

fn test_url_with_path():void! {
    println("Test 3: URL with path")
    var result = url.parse("http://example.com/api/users")
    assert(result.scheme == "http")
    assert(result.hostname == "example.com")
    assert(result.authority == "example.com")
    assert(result.port == 0)
    assert(result.path == "/api/users")
    assert(result.raw_query == "")
    assert(result.fragment == "")
    println("✓ URL with path test passed")
}

fn test_url_with_query():void! {
    println("Test 4: URL with query parameters")
    var result = url.parse("http://example.com/search?q=test")
    assert(result.scheme == "http")
    assert(result.hostname == "example.com")
    assert(result.authority == "example.com")
    assert(result.port == 0)
    assert(result.path == "/search")
    assert(result.raw_query == "q=test")
    assert(result.fragment == "")

    // Test query parsing
    var query = result.query()
    assert(query.get("q") == "test")
    assert(query["q"][0] == "test")
    println("✓ URL with query test passed")
}

fn test_url_with_fragment():void! {
    println("Test 5: URL with fragment")
    var result = url.parse("http://example.com/page#section1")
    assert(result.scheme == "http")
    assert(result.hostname == "example.com")
    assert(result.authority == "example.com")
    assert(result.port == 0)
    assert(result.path == "/page")
    assert(result.raw_query == "")
    assert(result.fragment == "section1")
    println("✓ URL with fragment test passed")
}

fn test_complete_url():void! {
    println("Test 6: Complete URL with all components")
    var result = url.parse("https://api.example.com:443/v1/users?id=123&name=john#profile")
    assert(result.scheme == "https")
    assert(result.hostname == "api.example.com")
    assert(result.authority == "api.example.com:443")
    assert(result.port == 443)
    assert(result.path == "/v1/users")
    assert(result.raw_query == "id=123&name=john")
    assert(result.fragment == "profile")

    // Test query parsing
    var query = result.query()
    assert(query.get("id") == "123")
    assert(query.get("name") == "john")
    println("✓ Complete URL test passed")
}

fn test_url_with_encoding():void! {
    println("Test 7: URL with encoded characters")
    var result = url.parse("http://example.com/search?q=hello%20world&name=john+doe")
    assert(result.scheme == "http")
    assert(result.hostname == "example.com")
    assert(result.authority == "example.com")
    assert(result.path == "/search")
    assert(result.raw_query == "q=hello%20world&name=john+doe")

    // Test URL decoding
    var query = result.query()
    assert(query["q"][0] == "hello world")  // %20 should decode to space
    assert(query["name"][0] == "john doe")  // + should decode to space
    println("✓ URL encoding test passed")
}

fn test_multiple_query_params():void! {
    println("Test 8: Multiple query parameters")
    var result = url.parse("http://example.com/api?tags=red&tags=blue&tags=green&limit=10")
    assert(result.raw_query == "tags=red&tags=blue&tags=green&limit=10")

    var query = result.query()
    assert(query["tags"].len() == 3)
    assert(query["tags"][0] == "red")
    assert(query["tags"][1] == "blue")
    assert(query["tags"][2] == "green")
    assert(query["limit"][0] == "10")
    println("✓ Multiple query parameters test passed")
}

fn test_edge_cases():void! {
    println("Test 9: Edge cases")

    // URL with only scheme and authority
    var result1 = url.parse("ftp://files.example.com")
    assert(result1.scheme == "ftp")
    assert(result1.hostname == "files.example.com")
    assert(result1.path == "/")

    // URL with empty path but with query
    var result2 = url.parse("http://example.com?search=test")
    assert(result2.scheme == "http")
    assert(result2.hostname == "example.com")
    assert(result2.path == "/")
    assert(result2.raw_query == "search=test")

    // URL with empty query value
    var result3 = url.parse("http://example.com/page?empty=&filled=value")
    var query3 = result3.query()
    assert(query3["empty"][0] == "")
    assert(query3["filled"][0] == "value")

    // URL with root path
    var result4 = url.parse("http://example.com/")
    assert(result4.path == "/")

    println("✓ Edge cases test passed")
}

fn test_error_cases():void! {
    println("Test 10: Error cases")

    // Test empty URL
    try {
        url.parse("")
        assert(false) // Should not reach here
    } catch e {
        println("✓ Empty URL correctly throws error", e.msg())
    }

    // Test invalid URL format (missing //)
    try {
        url.parse("http:example.com")
        assert(false) // Should not reach here
    } catch e {
        println("✓ Invalid URL format correctly throws error", e.msg())
    }

    // Test URL with only scheme
    try {
        url.parse("http:")
        assert(false) // Should not reach here
    } catch e {
        println("✓ Incomplete URL correctly throws error", e.msg())
    }

    println("✓ Error cases test passed")
}

=== test_conn_interface
--- main.n
import io
import io.buf
import net.tcp
import net.types

fn main() {
    var conn = tcp.connect('34.160.111.145:80')
    var http_request = 'GET /ip HTTP/1.1\r\n' +
                       'Host: ifconfig.me\r\n' +
                       'User-Agent: nature-client/1.0' +
                       'Accept: application/json\r\n' +
                       'Connection: close\r\n' +
                       '\r\n'

    conn.write(http_request as [u8])
    var br = new buf.reader<types.connable>(rd = conn)
    var line1 = br.read_line()
    println(line1)
    assert(line1 == 'HTTP/1.1 200 OK')
    println(br.read_line())
    println(br.read_line())
}

=== test_connect_timeout2
--- main.n
import net.tcp
import co

fn server():void! {
    var listener = tcp.listen('127.0.0.1:8080')

    for true {
        var conn = listener.accept()
        @async(fn():void! {
            var buf = vec_new<u8>(0, 1024)
            for true {
                var len = conn.read(buf) catch e {
                    println('conn read err:', e.msg())
                    -1
                }
                if len == -1 {
                    break
                }
                conn.write(buf[0..len])
            }

            conn.close()
        }(), co.SAME)
    }

    listener.close()
}

fn main() {
    go server()
    co.sleep(1000)

    var conn = tcp.connect_timeout('127.0.0.1:8080', 2000)
    println('success')
    conn.write('hello world' as [u8])
    println('write success')
}

=== test_timeout2
--- main.n
import co
import net.tls
import net.tcp

fn main() {
    var conn = tcp.connect_timeout('64.233.170.108:465', 50) catch e {
        println('in catch', e.msg())

        co.sleep(1000)
        return
    }
    println('connect success')
    co.sleep(1000)
}
