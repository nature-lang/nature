=== test_first
--- main.n
import fmt

type Display = interface{
	fn to_string():string
}

type DisplayPair<T>:Display = struct{
	T first
	T second
}

type Int<T>:Display = T

fn Int<T>.to_string():string {
	// this function returns a string.
	return fmt.sprintf("%d", *self)
}

fn DisplayPair<T>.to_string():string {
	//this function returns a string.
	return fmt.sprintf("DisplayPair(%s, %s)", self.first.to_string(), self.second.to_string());
}

fn main() {
	var display_pair = DisplayPair<Int<i32>>{first: -1, second: 2}
	println("DisplayPair: ", display_pair.to_string())
}

--- output.txt
DisplayPair:  DisplayPair(-1, 2)

=== test_second
--- main.n
import fmt
type Display = interface {
	fn to_string(): string;
};

type DisplayPair<T, U>:Display = struct {
	T first;
	U second;
};

type Int<T>:Display = T
type String:Display = string

fn Int<T>.to_string(): string {
	//this function returns a string.
	return fmt.sprintf("%d", *self)
}

fn String.to_string():string {
	//this function returns a string.
	return self as string;
}

fn DisplayPair<T, U>.to_string():string {
	//this function returns a string.
	return fmt.sprintf("DisplayPair(%s, %s)", self.first.to_string(), self.second.to_string());
}

fn main() {
	String str_value = "Hello, World!" // Literal quantities should be automatically inferred as custom string types
	var display_pair = DisplayPair<Int<i32>, String>{first: -1, second: str_value};
	println("DisplayPair: ", display_pair.to_string())
}

--- output.txt
DisplayPair:  DisplayPair(-1, Hello, World!)

=== test_third
--- main.n
import fmt
import runtime

type DisplayPair = struct{
	i32 first
	i32 second
}

fn i32.to_string():string {
    // println(self, *self)
    runtime.in_heap(self as anyptr)
	return fmt.sprintf("%d", *self)
}

fn main() {
	var display_pair = DisplayPair{first: 3, second: 2}
	var str = display_pair.first.to_string()
	var str2 = display_pair.second.to_string()
	println(str, str2)
	assert(str == '3' && str2 == '2')
}
