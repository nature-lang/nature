=== test_basic
--- main.n
fn foo<T>(T a) {
    var b = a
    println(b)
}

fn main() {
    foo(1.1)
    foo(1)
    foo(true)
}

--- output.txt
1.100000
1
true

=== test_basic_failed
--- main.n
fn foo<T>(T a) {
    var b = a
    println(b)
}

fn main() {
    foo(1.1)
    foo(1)
    foo<int>(true)
}

--- output.txt
nature-test/main.n:9:17: type inconsistency, expect=i64, actual=bool


=== test_impl_check_failed
--- main.n
fn foo<T>(T a) {
    var b = a.hello()
    println(b)
}

fn main() {
}

--- output.txt
nature-test/main.n:2:20: generic param 'T' has no constraint declaring fn 'hello'

=== test_impl_check_failed2
--- main.n
type helloable = interface{}

#where T:helloable
fn foo<T>(T a) {
    var b = a.hello()
    println(b)
}

fn main() {
}

--- output.txt
nature-test/main.n:5:20: generic param 'T' has no constraint declaring fn 'hello'



=== test_impl_check
--- main.n
type helloable = interface{
    fn hello()
}

#where T:helloable
fn foo<T>(T a) {
    var b = a.hello()
    println(b)
}

fn main() {
}


=== test_opr_failed
--- main.n
fn foo<T>(T a) {
    var c = a * 2
    println(c)
}

fn main() {
}

--- output.txt
nature-test/main.n:2:17: generic param 'T' cannot use operator '*' without 'numeric' constraint

=== test_opr_failed2
--- main.n
fn foo<T>(T a) {
    var c = a + 2
    println(c)
}

fn main() {
}

--- output.txt
nature-test/main.n:2:17: generic param 'T' cannot use operator '+' without 'addable' constraint

=== test_opr_basic
--- main.n
#where T:addable
fn foo<T>(T a) {
    var c = a + 2
    println(c)
}

fn main() {
}

=== test_opr_basic2
--- main.n
#where T:numeric
fn foo<T>(T a) {
    var c = a + 2
    println(c)
}

fn main() {
}

=== test_bool_condition_failed
--- main.n
fn foo<T>(T v) {
    if v {
        println("ok")
    }
}

fn main() {
}

--- output.txt
nature-test/main.n:2:8: generic param 'T' cannot be used as bool value

=== test_boolike_interface_as_bool
--- main.n
type boolike = interface{
    fn as_bool():bool
}

type flag_t:boolike = struct{
    bool value
}

fn flag_t.as_bool(self):bool {
    return self.value
}

#where T:boolike
fn foo<T>(T v):bool {
    if v.as_bool() {
        return true
    }
    return false
}

fn main() {
    assert(foo(flag_t{value:true}))
    assert(!foo(flag_t{value:false}))
}


=== test_comparable_builtin_int
--- main.n
#where T:comparable
fn max<T>(T a, T b):T {
    if a > b {
        return a
    }
    return b
}

fn main() {
    assert(max(3, 1) == 3)
}

=== test_addable_builtin_int
--- main.n
#where T:addable
fn plus<T>(T a, T b):T {
    return a + b
}

fn main() {
    assert(plus(1, 2) == 3)
}

=== test_numeric_unary_binary
--- main.n
#where T:numeric
fn invert<T>(T a):T {
    return ~a
}

#where T:numeric
fn gt<T>(T a, T b):bool {
    return a > b
}

fn main() {
    assert(invert(1) == -2)
    assert(gt(3, 2))
}

=== test_missing_addable_constraint
--- main.n
#where T:comparable
fn plus<T>(T a, T b):T {
    return a + b
}

fn main() {
}

--- output.txt
nature-test/main.n:3:16: generic param 'T' cannot use operator '+' without 'addable' constraint


=== test_multi_constraints
--- main.n
type Test1able = interface{
    fn test1()
}

type Test2able = interface{
    fn test2()
}

#where T:Test1able&Test2able
fn call_all<T>(T a) {
    a.test1()
    a.test2()
}

fn main() {
}


=== test_multi_params_constraints
--- main.n
type Test1able = interface{
    fn test1()
}

type Test2able = interface{
    fn test2()
}

type Testuable = interface{
    fn testu()
}

#where T:Test1able&Test2able,U:Testuable
fn call_all<T,U>(T a, U b) {
    a.test1()
    a.test2()
    b.testu()
}

fn main() {
}


=== test_multi_params_constraints_call_assert
--- main.n
type Test1able = interface{
    fn test1():int
}

type Test2able = interface{
    fn test2():int
}

type Testuable = interface{
    fn testu():int
}

type both_t:Test1able,Test2able = struct{}

fn both_t.test1(self):int {
    return 11
}

fn both_t.test2(self):int {
    return 22
}

type user_t:Testuable = struct{}

fn user_t.testu(self):int {
    return 33
}

#where T:Test1able&Test2able,U:Testuable
fn call_all<T,U>(T a, U b):int {
    return a.test1() + a.test2() + b.testu()
}

fn main() {
    int v = call_all(both_t{}, user_t{})
    assert(v == 66)
}


=== test_multi_params_constraints_call_failed_missing_method
--- main.n
type Test1able = interface{
    fn test1():int
}

type Test2able = interface{
    fn test2():int
}

type Testuable = interface{
    fn testu():int
}

type both_t:Test1able,Test2able = struct{}

fn both_t.test1(self):int {
    return 11
}

fn both_t.test2(self):int {
    return 22
}

type bad_u = struct{}

#where T:Test1able&Test2able,U:Testuable
fn call_all<T,U>(T a, U b):int {
    return a.test1() + a.test2() + b.testu()
}

fn main() {
    int v = call_all(both_t{}, bad_u{})
    assert(v == 66)
}

--- output.txt
nature-test/main.n:31:37: type 'main.bad_u' not impl 'main.Testuable' interface


=== test_nonvoid_basic
--- main.n
#where T:nonvoid
fn id<T>(T v):T {
    return v
}

fn main() {
    assert(id(1) == 1)
}


=== test_nonvoid_failed_void_arg
--- main.n
#where T:nonvoid
fn run<T>() {
    println('ok')
}

fn main() {
    run<void>()
}

--- output.txt
nature-test/main.n:7:8: type 'void' denied by 'nonvoid' interface


=== test_basic
--- main.n
type foo_t<T> = T|int

fn foo_t<T>.hello(self):string {
    if self is int {
        return 'hello'
    } else {
        return 'unknown'
    }
}

fn foo_t<T>.world(self):string {
    if self is float {
        return 'world'
    } else {
        return 'unknown'
    }
}

fn main():void! {
    foo_t<float> v = 3.14
    println(v.hello())
    println(v.world())
    assert(v.hello() == 'unknown')
    assert(v.world() == 'world')
}

=== test_impl_infer
--- main.n
type box_t<T> = struct{
    T value
}

fn box_t<T>.get(self):T {
    return self.value
}

fn box_t<T>.set(*self, T value) {
    self.value = value
}

fn main():void! {
    box_t<int> b = box_t<int>{value: 1}
    println(b.get())
    b.set(3)
    println(b.get())

    box_t<string> s = box_t<string>{value: 'hi'}
    println(s.get())
}

--- output.txt
1
3
hi
