import libc

fn vec_new<T>(ptr<T> p, int len):vec<T>! {
    if len < 0 {
        throw errorf("invalid vec index '%d' (must be non-negative)", len)
    }

    int hash = @reflect_hash(vec<T>)
    int ele_hash = @reflect_hash(T)

    return unsafe_vec_new<T>(hash, ele_hash, len, p as anyptr)
}

#local #linkid unsafe_vec_new
fn unsafe_vec_new<T>(int hash, int ele_hash, int len, anyptr p):vec<T>!

fn ptr_to<T>(anyptr p):T {
    return *(p as ptr<T>)
}

fn ptr_copy<T>(anyptr dst, ptr<T> src) {
    var dst2 = dst as ptr<T>

    var size = @sizeof(T)
    // *dst2 = *src
    libc.memmove(dst, src as anyptr, size as u64)
}
